#!/usr/bin/perl
use strict;
use Getopt::Std;
use Pod::Usage;
use Parse::MediaWikiDump;

getopts("hc:l:i:", \my %opts);

pod2usage(-verbose => 1) if $opts{h};
pod2usage unless @ARGV;

binmode(STDOUT, ":utf8");

my $show_context = $opts{c} || 30;
my $show_contextlines = $opts{l} || 0;
my $show_info = $opts{i} || 0;
my $count = 0;
my $modstr = $ARGV[0];
my $mod;
my $fileext;
if ($modstr eq "dk") {
  $mod = \&mod_datumsformat;
} elsif ($modstr eq "sl" ) {
  $mod = \&mod_selbstlinks;
} elsif ($modstr eq "grep" ) {
  shift(@ARGV);
  $mod = \&mod_simpleregexp;
} else {
  pod2usage("no module selected");
}

#mod_selbstlinks($p, $title, $text);
#mod_plusdagger($p, $title, $text);

my $filename = $ARGV[1];

my %found;
my %context;
my %info;

my $parser= Parse::MediaWikiDump::Pages->new($filename);

###########################################
# Main
###########################################

my $page;

my $time_start = time;
my $time_last = $time_start;

while(defined($page = $parser->next)) {
  $count++;

  my $title = $page->title;

  &$mod($page);
  
  print_progress() if ($count % 1000 == 0);

  if ($found{$title}){
    chomp $context{$title};
    output_one($title);
  }
}

print_progress();
print_stats();

###########################################
sub print_progress {
###########################################
  my $time_cur = time;

  my $byte_cur = $parser->current_byte;
  my $size = $parser->size;
  my $time_diff = $time_cur - $time_start;
  my $rate = $byte_cur / ($time_cur - $time_start);
  my $eta = int (($size - $byte_cur) / $rate);
  printf STDERR '%2.2f%% %d:%02d %d:%02d (%.2f MB/s)'."\n", 
    $byte_cur/$size*100,
    $time_diff / 60,
    $time_diff % 60,
    $eta / 60,
    $eta % 60,
    $rate / 1024 / 1024;

  $time_last = $time_cur;
}

###########################################
sub print_stats {
###########################################
  my $hits = scalar keys %found;
  printf STDERR "hits %d/%d (%.2f%%)\n",
    $hits, $count, 1.0 * $hits / $count * 100;
}

###########################################
# Modules
###########################################

###########################################
sub mod_simpleregexp {
###########################################
  my($page) = @_;
  $_ = ${$page->text};
  while (/$ARGV[0]/i) {
    insert_found($page->title,$`,$&,$');
    $_=$';
  }
}

###########################################
sub mod_selbstlinks {
###########################################
  my($page) = @_;
  my($title, $text) = ($page->title, ${$page->text});
  $_ = $text;
  while (/\[\[([^\]\|]+)(\||\]\])/) {
    if ($1 eq $title) {
      insert_found($title,$`,$&,$');
    }
    $_=$';
  }
}

###########################################
sub mod_datumsformat {
###########################################
  my($page) = @_;
  return unless $page->namespace eq ''; # nur Artikel-Namensrausm
  
  $_ = ${$page->text};

  s/== *(Literatur|Weblinks?|Quellen?|Bibliogra(ph|f)ie)(.*?)==(.*?)(?===|\[\[Kategorie|\{\{Personendaten|$)//sg; # Abschnitte entfernen
  s/\{\{ChartplatzierungenX?\}\}(.*?)<\/div>//sg; # chartboxen

  # todo: 
  # Zitat-Vorlagen
  # "vermutlich http-link" überprüfen
  # Chartplatzierungen sieht komisch aus
  # Literatur/Weblinks/etc.-Abschnitte verbessern (auch "===")
  # Kommentare über mehrere Zeilen werden nicht erkannt
  # [[MaK V 100 PA]] Abbildungsname in Infobox

  while (/(\d{1,2})\. ?(\d{1,2})\. ?(\d{2}(\d{2})?)/g) {
    if ($' !~ /^\.?\d/ and   # nur drei Zahlengruppen
        $` !~ /\d\.?$/ and  
	$2 <= 12 and  # plausibles Datum 
	$2 >= 1 and  # plausibles Datum 
	$1 <= 31 and
	$1 >= 1 and
	$` !~ /http:\/\/\S*$/ and # link
	$' !~ /^\s*<!-- ?sic/ and #sic-Kommentar
        $` !~ /[|=]\s*$/s and # parameter oder Tabelle
        $' !~ /^\s*\|/s and # parameter oder Tabelle
        $' !~ /^[^\[\]]*\][^\]]+/s and # vermutlich http-link
	$' !~ /^[^<]*<\/(ref|small|gallery)>/s and # small- und ref-Tag
	$' !~ /^[^<]*\/>/ and # für <ref name="....." />
	$` !~ /<!--[^>]*$/s and # Kommentar
        $` !~ /\{\{PND[^\}]*$/s and # im PND Eintrag
        $` !~ /\[\[(Bild|Image):[^\]\|]*$/i # Bild-Wikilink
      ) {
      insert_found($page->title,$`,$&,$');
    }
  }
}

###########################################
sub mod_plusdagger {
###########################################
  my($p, $title, $text) = @_;
  $_ = $text;
  while (/[;,] ?\+ ?(\[\[)?\d{1,2}\./) {
    insert_found($title,$`,$&,$');
    $_ = $';
  }
}

###########################################
# Allgemeine Routinen
###########################################

###########################################
sub insert_found {
###########################################
  my($title, $before, $match, $after) = @_;
  $found{$title}++;
  $context{$title} .= substr($before,length($before)-$show_context,$show_context)
        	      .$match.substr($after,0,$show_context)."\n";
  if ($found{$title} <= $show_info || $show_info == -1) {
    $info{$title} .= ", $match";
  } elsif ($found{$title} == $show_info + 1 && $show_info != 0) {
    $info{$title} .= ", ...";
  }
}

###########################################
sub output_one {
###########################################
  my ($title) = @_;
  my $found = $found{$title};
  my $context = $context{$title};
  print "*[[$title]]";
  if ($info{$title}) {
    print $info{$title};
  }
  if ($found > $show_info) {
    print " ($found)";
  }
  print "\n";
  $| = 1;
  my $i = 0;
  foreach my $line (split /\n/, $context) {
    if ($i++ < $show_contextlines || $show_contextlines == -1) { 
      print "<nowiki>$line</nowiki><br/>\n"; 
    }
  }
}

__END__

=head1 NAME

wikidump-parser - Parse wikipedias xml-dump

=head1 SYNOPSIS

wikidump-parser [-h] [-i <#>] [-l <#>] [-c <#>] <mod> <xml-dump-file>

=head1 ARGUMENTS

  dk     # Datumskonvention (1.1.2000)
  sl     # Selbstlinks
  grep <regexp>
         # use the userspecitifed regexp for grep

=head1 OPTIONS

  -i <#> # num. of occurences to be shown (0), -1=infty
  -l <#> # num. of context-lines to be shown (0), -1=infty;
  -l <#> # num. of context-chars to be shown before/after occurence (30)
  -h     # show help
