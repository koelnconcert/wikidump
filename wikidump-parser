#!/usr/bin/perl
use strict;
use Getopt::Std;
use Pod::Usage;
use Parse::MediaWikiDump;

binmode(STDOUT, ":utf8");

my %modules = ( 
  dk => { 
    name => "Datumskonventionen", 
    func => \&mod_datumsformat,
    show_info => 5,
    show_contextlines => 5
  },
  bkl => { 
    name => "Begriffsklaerung", 
    func => \&mod_bkl,
    show_info => -1
  },
  red => { 
    name => "Redirects", 
    func => \&mod_redirects,
    redirects => 1, 
    show_info => -1,
    show_contextlines => -1
  },
  dagger => { 
    name => "Pluszeichen als Dagger", 
    func => \&mod_plusdagger,
    show_context => 10,
    show_contextlines => 5
  },
  'grep' => {
    name => "Grep",
    func => \&mod_simpleregexp,
    show_contextlines => 1
  }
);

getopts("hc:l:i:", \my %opts);

pod2usage(-verbose => 1) if $opts{h};
pod2usage unless @ARGV;

my $filename = shift @ARGV;

my @mods;

pod2usage("no module selected") if scalar @ARGV == 0;
for (@ARGV) {
  my $mod = $modules{$_};
  pod2usage("module $_ is unkown") if not defined $mod;
  push @mods, $mod;
  $mod->{show_context} ||= 30;
  $mod->{show_contextlines} ||= 0;
  $mod->{show_info} ||=0;
  $mod->{show_contextlines} = $opts{l} if defined $opts{l};
  $mod->{show_info} = $opts{i} if defined $opts{i};
  $mod->{shortname} = $_;
  $mod->{redirects} ||=0;
}

my $count = 0;

#TODO: diese globalen Variablen entfernen
my $found;
my $context;
my $info;

my $parser= Parse::MediaWikiDump::Pages->new($filename);

###########################################
# Main
###########################################

my $page;

my $time_start = time;
my $time_last = $time_start;

while(defined($page = $parser->next)) {
  $count++;

  my $title = $page->title;

  foreach my $mod (@mods) {
    ($found, $context, $info) = ();

    $mod->{func}->($mod, $page) unless $page->redirect and !$mod->{redirects};
  
    output_one($mod, $title) if $found;
  }
  
  print_progress() if ($count % 1000 == 0);
}

print_progress();
print_stats();

###########################################
sub print_progress {
###########################################
  my $time_cur = time;

  my $byte_cur = $parser->current_byte;
  my $size = $parser->size;
  my $time_diff = $time_cur - $time_start;
  my $rate = $byte_cur / ($time_cur - $time_start);
  my $eta = int (($size - $byte_cur) / $rate);
  printf STDERR '%2.2f%% %d:%02d %d:%02d (%.2f MB/s)'."\n", 
    $byte_cur/$size*100,
    $time_diff / 60,
    $time_diff % 60,
    $eta / 60,
    $eta % 60,
    $rate / 1024 / 1024;

  $time_last = $time_cur;
}

###########################################
sub print_stats {
###########################################
#  my $hits = scalar keys %found;
#  printf STDERR "hits %d/%d (%.2f%%)\n",
#    $hits, $count, 1.0 * $hits / $count * 100;
}

###########################################
# Modules
###########################################

###########################################
sub mod_simpleregexp {
###########################################
  my($mod, $page) = @_;
  $_ = ${$page->text};
  while (/Begriffskl.rung/i) {
    insert_found($mod, $page->title,$`,$&,$');
    $_=$';
  }
}

###########################################
sub mod_selbstlinks {
###########################################
  my($page) = @_;
  my($title, $text) = ($page->title, ${$page->text});
  $_ = $text;
  while (/\[\[([^\]\|]+)(\||\]\])/) {
    if ($1 eq $title) {
      insert_found($title,$`,$&,$');
    }
    $_=$';
  }
}

###########################################
sub mod_bkl {
###########################################
  my($mod, $page) = @_;
  return unless $page->namespace eq ''; # nur Artikel-Namensrausm
  my $title = $page->title;
  $_ = ${$page->text};
  if (/\{\{Begriffskl.rung\}\}/i) {
    insert_simple($mod, $title ,"Position der Vorlage") if ($` =~ /^\s*$/);
    insert_simple($mod, $title, "Aufzaehlung") if (/^\s*#/m);
  }
  if (/\[\[Kategorie: *Begriffskl.rung/i) {
    insert_simple($mod, $title, "Kategorie");
  }
}

###########################################
sub mod_redirects {
###########################################
  my($mod, $page) = @_;
  return unless $page->redirect;
  my $title = $page->title;
  $_ = ${$page->text};
  #s/\#REDIRECT[ :]*\[\[.*?\]\]\.?//i; 
  s/\#REDIRECT.*$//mi; 
  my $context_hack = $_; #Hack
  s/\[\[.*?\]\]//g; # Links entfernen (inkl. Kategorien)
  s/\{\{.*?\}\}//sg; # Vorlagen entfernen
  s/\s//g; # Leerzeichen entfernen
  insert_simple($mod, $title ,"Text (" . (length $_) . ")") if length $_ > 0; 
  $context = $context_hack;
}

###########################################
sub mod_datumsformat {
###########################################
  my($mod, $page) = @_;
  return unless $page->namespace eq ''; # nur Artikel-Namensrausm
  
  $_ = ${$page->text};

  s/<!--.*?-->/<!-- -->/sg; # Kommentare leeren

  s/== *(Literatur|Weblinks?|Quellen?|Bibliogra(ph|f)ie)(.*?)==(.*?)(?===|\[\[Kategorie|\{\{Personendaten|$)//sg; # Abschnitte entfernen
  s/\{\{ChartplatzierungenX?\}\}(.*?)<\/div>//sg; # chartboxen

  # todo: 
  # Zitat-Vorlagen
  # "vermutlich http-link" überprüfen
  # Chartplatzierungen sieht komisch aus
  # Literatur/Weblinks/etc.-Abschnitte verbessern (auch "===")
  #   z.B. [[Alfred Philippson]]
  # {{Großes Bild}} 

  sub _check {
    my ($day, $month, $year, $before, $after) = @_;
    my ($a, $b) = ($after, $before);
    return (
      $month <= 12 and  # plausibles Datum 
      $month >= 1 and  # plausibles Datum 
      $day <= 31 and
      $day >= 1 and
      $year <= 2100 and
      $b !~ /http:\/\/\S*$/ and # link
      $a !~ /^\s*<!--/ and # Kommentar danach
      $b !~ /[|=]\s*$/s and # parameter oder Tabelle
      $a !~ /^\s*\|/s and # parameter oder Tabelle
      $a !~ /^[^\[\]]*\][^\]]+/s and # vermutlich http-link
      $a !~ /^[^<]*<\/(ref)>/s and # small- und ref-Tag
      $a !~ /^[^<]*\/>/ and # für <ref name="....." />
      $b !~ /\{\{PND[^\}]*$/s and # im PND Eintrag
      $a !~ /^[^|\n\[]*\.(jpe?g|gif|svg|png|ogg) *[|\n]/i and
        # Zeilen/Parameter mit Bild-Endungen am Ende
      $a !~ /^(-?[A-Z]|-\d(?!\d*\.\d))/i and # nicht "freistehend"
        # filtert "er-Zweig", "-rc1"," -12", aber nicht "-12.3.1999"
      $b !~ /(version|kernel|linux|mac os|os x)(\]\])?\s*$/i and 
        # Buzz-Wort
      1
    );
  }

  #
  # 1.2.1999, 01.02.99
  #

  while (/(?<![.0-9])(\d{1,2})\. ?(\d{1,2})\. ?(\d{2}(\d{2})?)(?!\.?\d)/g) {
    insert_found($mod, $page->title,$`,$&,$') if _check($1, $2, $3, $`, $');
  }

  #
  # 1999-2-1, 1999-02-01
  #
  
  while (/(?<![\-0-9])(\d{4})-(\d{1,2})-(\d{1,2})(?![\-0-9])/g) {
    if (_check($3, $2, $1, $`, $') and
        $` !~ /(CAS|DIN|EN|VDE|ISO|EC).{0,9}$/ 
    ) {
      insert_found($mod, $page->title,$`,$&,$') 
    }
  }

  #
  # 01. Februar 1999,  02. Apr. 2008
  #
 
  my %monat = (
    Januar => 1, "Jan." => 2, "Jänner" => 1, "Jän." => 1,
    Februar => 2, "Feb." => 2,
    "März" => 3, "Mär" => 3,
    April => 4, "Apr." => 4,
    Mai => 5,
    Juni => 6, "Jun." => 6,
    Juli => 7, "Jul." => 7,
    August => 8, "Aug." => 8,
    September => 9, "Sep." => 9,
    Oktober => 10, "Okt." => 10,
    November => 11, "Nov." => 11,
    Dezember => 12, "Dez." => 12 );

  while (/\b(0\d)\.\s*([\w\.]+)\s+(\d{4})(?!\d)/g) {
    if (defined $monat{$2} and
        _check($1, $monat{$2}, 2000, $`, $')
    ) {
      insert_found($mod, $page->title,$`,$&,$');
    }
  }

  #
  # 1. Januar 38
  #

  if (! /[vn]\. Chr\./) {
    while (/\b(\d{1,2})\.\s*([\w\.]+)\s+(\d{2})(?!\.?\d)/g) {
      if (defined $monat{$2} and
          _check($1, $monat{$2}, 2000, $`, $')
      ) {
#        insert_found($mod, $page->title,$`,$&,$');
      }
    }
  }

}

###########################################
sub mod_plusdagger {
###########################################
  my($mod, $page) = @_;
  $_ = ${$page->text};
  while (/[(;,] ?\+ ?(\[\[)?\d{1,2}\./) {
    insert_found($mod, $page->title,$`,$&,$');
    $_ = $';
  }
}

###########################################
# Allgemeine Routinen
###########################################

###########################################
sub insert_found {
###########################################
  my($mod, $title, $before, $match, $after) = @_;
  my $show_context = $mod->{show_context};
  my $show_info = $mod->{show_info};
  
  $found++;
  if ($show_context) {
    $context .= substr($before,length($before)-$show_context,$show_context)
        	      .$match.substr($after,0,$show_context)."\n";
  }
  if ($found <= $show_info || $show_info == -1) {
    $info .= ", $match";
  } elsif ($found == $show_info + 1 && $show_info != 0) {
    $info .= ", ...";
  }
}

###########################################
sub insert_simple {
###########################################
  my ($mod, $title, $text) = @_;
  insert_found($mod, $title, undef, $text, undef);
}

###########################################
sub output_one {
###########################################
  my ($mod, $title) = @_;
  my $show_context = $mod->{show_context};
  my $show_info = $mod->{show_info};
  my $show_contextlines = $mod->{show_contextlines};
  chomp $context;
  print "$mod->{shortname}: ";
  print "*[[$title]]";
  if ($info) {
    print $info;
  }
  if ($found > $show_info && $show_info >= 0) {
    print " ($found)";
  }
  print "\n";
  $| = 1;
  my $i = 0;
  foreach my $line (split /\n/, $context) {
    if ($i++ < $show_contextlines || $show_contextlines == -1) { 
      print "$mod->{shortname}: ";
      print "**<nowiki>$line</nowiki>\n"; 
    }
  }
}

__END__

=head1 NAME

wikidump-parser - Parse wikipedias xml-dump

=head1 SYNOPSIS

wikidump-parser [-h] [-i <#>] [-l <#>] [-c <#>] <mod> <xml-dump-file>

=head1 ARGUMENTS

  dk     # Datumskonvention (1.1.2000)
  sl     # Selbstlinks
  grep <regexp>
         # use the userspecitifed regexp for grep

=head1 OPTIONS

  -i <#> # num. of occurences to be shown (0), -1=infty
  -l <#> # num. of context-lines to be shown (0), -1=infty;
  -l <#> # num. of context-chars to be shown before/after occurence (30)
  -h     # show help
